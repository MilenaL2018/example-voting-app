# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the action will run. Triggers the workflow on push or pull request
# events but only for the master branch
on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
     
      - name: Login to DockerHub Registry
        run: echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USER }} --password-stdin
        
      - name: Build result
        run: docker build -t milelucero98/result:latest ./result
        
      - name: Push result
        run: docker push milelucero98/result:latest
        
      - name: Build vote
        run: docker build -t milelucero98/vote:latest ./vote
      
      - name: Push vote
        run: docker push milelucero98/vote:latest
      
      - name: Build worker 
        run: docker build -t milelucero98/worker:latest ./worker
        
      - name: Push worker
        run: docker push milelucero98/worker:latest
        
  deployVote:
    name: Deploy Vote in Heroku
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - uses: actions/checkout@v2
      - name: Login to Heroku Container registry
        env: 
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: heroku container:login 
      - name: Setting Vars
        env: 
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: |
          heroku config:set REDIS_PORT=${{ secrets.REDIS_PORT }} -a example-voting-app-vote
          heroku config:set REDIS_HOST=${{ secrets.REDIS_HOST }} -a example-voting-app-vote
          heroku config:set REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }} -a example-voting-app-vote
      - name: Build and Push
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: |
          cd ./vote
          heroku container:push -a example-voting-app-vote web
      - name: Release
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: heroku container:release -a example-voting-app-vote web
  
  deployWorker:
    name: Deploy Worker in Heroku
    runs-on: ubuntu-latest
    needs: [build, deployVote]
    steps:
      - uses: actions/checkout@v2
      - name: Login to Heroku Container registry
        env: 
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: heroku container:login
      - name: Setting Vars
        env: 
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: |
          heroku config:set POSTGRES_PORT=${{ secrets.POSTGRES_PORT  }} -a example-voting-app-worker
          heroku config:set POSTGRES_DATABASE=${{ secrets.POSTGRES_DATABASE  }} -a example-voting-app-worker
          heroku config:set POSTGRES_HOST=${{ secrets.POSTGRES_HOST  }} -a example-voting-app-worker
          heroku config:set POSTGRES_USER=${{ secrets.POSTGRES_USER  }} -a example-voting-app-worker
          heroku config:set POSTGRES_PASS=${{ secrets.POSTGRES_PASS  }} -a example-voting-app-worker
          heroku config:set POSTGRES_URI=${{ secrets.POSTGRES_URI   }} -a example-voting-app-worker
          heroku config:set REDIS_PORT=${{ secrets.REDIS_PORT }} -a example-voting-app-worker
          heroku config:set REDIS_HOST=${{ secrets.REDIS_HOST }} -a example-voting-app-worker
          heroku config:set REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }} -a example-voting-app-worker
      - name: Build and Push
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: |
          cd ./worker
          heroku container:push -a example-voting-app-worker web
      - name: Release
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: heroku container:release -a example-voting-app-worker web
  
  deployResult:
    name: Deploy Result in Heroku
    runs-on: ubuntu-latest
    needs: [build, deployWorker]
    steps:
      - uses: actions/checkout@v2
      - name: Login to Heroku Container registry
        env: 
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: heroku container:login 
      - name: Setting Vars
        env: 
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: |
          heroku config:set POSTGRES_URI=${{ secrets.POSTGRES_URI }} -a example-voting-app-result
      - name: Build and Push
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: |
          cd ./result
          heroku container:push -a example-voting-app-result web
      - name: Release
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API }}
        run: heroku container:release -a example-voting-app-result web
  
  #unit_testing_vote:
  #  runs-on: ubuntu-latest
  #  needs: [build, deployVote]
  #  strategy:
  #    matrix:
  #      python-version: [2.7, 3.5, 3.6, 3.7, 3.8]
#
  #  steps:
  #    - uses: actions/checkout@v2
  #    - name: Set up Python
  #      uses: actions/setup-python@v2
  #      with:
  #        python-version: '3.x'
  #    - name: Install dependencies
  #      run: |
  #        python -m pip install --upgrade pip
  #        pip install -r requirements.txt
#
  #    - name: PyTest
  #      run: python -m pytest test --junit-xml pytest.xml
  #
  #    - name: Upload Unit Test Results
  #      if: always()
  #      uses: actions/upload-artifact@v2
  #      with:
  #        name: Unit Test Results (Python ${{ matrix.python-version }})
  #        path: pytest.xml
  
  #publish-test-results:
  #    name: "Publish Unit Tests Results"
  #    needs: unit_testing_vote
  #    runs-on: ubuntu-latest
  #    # the build-and-test job might be skipped, we don't need to run this job then
  #    if: success() || failure()
  #
  #    steps:
  #      - name: Download Artifacts
  #        uses: actions/download-artifact@v2
  #        with:
  #          path: artifacts
  #
  #      - name: Publish Unit Test Results
  #        uses: EnricoMi/publish-unit-test-result-action@v1.4
  #        with:
  #          check_name: Unit Test Results
  #          github_token: ${{ secrets.GITHUB_TOKEN }}
  #          files: pytest.xml
  #
  #unit_testing_worker:
  #  runs-on: ubuntu-latest
  #
  #  steps:
  #      - uses: actions/checkout@v2
  #      - name: Set up JDK 1.8
  #        uses: actions/setup-java@v1
  #        with:
  #          java-version: 1.8
  #      - name: Build with Maven
  #        run: mvn -B package --file pom.xml
  
  
  ##integration-testing:
    #runs-on: ubuntu-latest
    #needs: [deploy_result]
    #steps:  
    #  steps:
    #     - uses: actions/checkout@v2
    #     - name: Integration Test
    #       uses: 
    #  
    #     - name: Archive  results
    #       uses: actions/upload-artifact@v2
    #         with:
    #           name: integration-test-report
    #           path: output/result.xml
    #  
    #  
   
  ###sonarcloud:
  #  name: SonarCloud
  #  runs-on: ubuntu-latest
  #  steps:
  #    - uses: actions/checkout@v2
  #      with:
  #        fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
  #    - name: SonarCloud Scan
  #      uses: SonarSource/sonarcloud-github-action@master
  #      env:
  #        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
  #        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  #     
  #     
          
